// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"ekko/pkg/ent/migrate"

	"ekko/pkg/ent/answersubmission"
	"ekko/pkg/ent/question"
	"ekko/pkg/ent/scenario"
	"ekko/pkg/ent/scenariocandidate"
	"ekko/pkg/ent/scenariofavorite"
	"ekko/pkg/ent/scenariofield"
	"ekko/pkg/ent/submissionattempt"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AnswerSubmission is the client for interacting with the AnswerSubmission builders.
	AnswerSubmission *AnswerSubmissionClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// Scenario is the client for interacting with the Scenario builders.
	Scenario *ScenarioClient
	// ScenarioCandidate is the client for interacting with the ScenarioCandidate builders.
	ScenarioCandidate *ScenarioCandidateClient
	// ScenarioFavorite is the client for interacting with the ScenarioFavorite builders.
	ScenarioFavorite *ScenarioFavoriteClient
	// ScenarioField is the client for interacting with the ScenarioField builders.
	ScenarioField *ScenarioFieldClient
	// SubmissionAttempt is the client for interacting with the SubmissionAttempt builders.
	SubmissionAttempt *SubmissionAttemptClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AnswerSubmission = NewAnswerSubmissionClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.Scenario = NewScenarioClient(c.config)
	c.ScenarioCandidate = NewScenarioCandidateClient(c.config)
	c.ScenarioFavorite = NewScenarioFavoriteClient(c.config)
	c.ScenarioField = NewScenarioFieldClient(c.config)
	c.SubmissionAttempt = NewSubmissionAttemptClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AnswerSubmission:  NewAnswerSubmissionClient(cfg),
		Question:          NewQuestionClient(cfg),
		Scenario:          NewScenarioClient(cfg),
		ScenarioCandidate: NewScenarioCandidateClient(cfg),
		ScenarioFavorite:  NewScenarioFavoriteClient(cfg),
		ScenarioField:     NewScenarioFieldClient(cfg),
		SubmissionAttempt: NewSubmissionAttemptClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AnswerSubmission:  NewAnswerSubmissionClient(cfg),
		Question:          NewQuestionClient(cfg),
		Scenario:          NewScenarioClient(cfg),
		ScenarioCandidate: NewScenarioCandidateClient(cfg),
		ScenarioFavorite:  NewScenarioFavoriteClient(cfg),
		ScenarioField:     NewScenarioFieldClient(cfg),
		SubmissionAttempt: NewSubmissionAttemptClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AnswerSubmission.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AnswerSubmission, c.Question, c.Scenario, c.ScenarioCandidate,
		c.ScenarioFavorite, c.ScenarioField, c.SubmissionAttempt,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AnswerSubmission, c.Question, c.Scenario, c.ScenarioCandidate,
		c.ScenarioFavorite, c.ScenarioField, c.SubmissionAttempt,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AnswerSubmissionMutation:
		return c.AnswerSubmission.mutate(ctx, m)
	case *QuestionMutation:
		return c.Question.mutate(ctx, m)
	case *ScenarioMutation:
		return c.Scenario.mutate(ctx, m)
	case *ScenarioCandidateMutation:
		return c.ScenarioCandidate.mutate(ctx, m)
	case *ScenarioFavoriteMutation:
		return c.ScenarioFavorite.mutate(ctx, m)
	case *ScenarioFieldMutation:
		return c.ScenarioField.mutate(ctx, m)
	case *SubmissionAttemptMutation:
		return c.SubmissionAttempt.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AnswerSubmissionClient is a client for the AnswerSubmission schema.
type AnswerSubmissionClient struct {
	config
}

// NewAnswerSubmissionClient returns a client for the AnswerSubmission from the given config.
func NewAnswerSubmissionClient(c config) *AnswerSubmissionClient {
	return &AnswerSubmissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `answersubmission.Hooks(f(g(h())))`.
func (c *AnswerSubmissionClient) Use(hooks ...Hook) {
	c.hooks.AnswerSubmission = append(c.hooks.AnswerSubmission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `answersubmission.Intercept(f(g(h())))`.
func (c *AnswerSubmissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AnswerSubmission = append(c.inters.AnswerSubmission, interceptors...)
}

// Create returns a builder for creating a AnswerSubmission entity.
func (c *AnswerSubmissionClient) Create() *AnswerSubmissionCreate {
	mutation := newAnswerSubmissionMutation(c.config, OpCreate)
	return &AnswerSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AnswerSubmission entities.
func (c *AnswerSubmissionClient) CreateBulk(builders ...*AnswerSubmissionCreate) *AnswerSubmissionCreateBulk {
	return &AnswerSubmissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnswerSubmissionClient) MapCreateBulk(slice any, setFunc func(*AnswerSubmissionCreate, int)) *AnswerSubmissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnswerSubmissionCreateBulk{err: fmt.Errorf("calling to AnswerSubmissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnswerSubmissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnswerSubmissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AnswerSubmission.
func (c *AnswerSubmissionClient) Update() *AnswerSubmissionUpdate {
	mutation := newAnswerSubmissionMutation(c.config, OpUpdate)
	return &AnswerSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnswerSubmissionClient) UpdateOne(as *AnswerSubmission) *AnswerSubmissionUpdateOne {
	mutation := newAnswerSubmissionMutation(c.config, OpUpdateOne, withAnswerSubmission(as))
	return &AnswerSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnswerSubmissionClient) UpdateOneID(id uint64) *AnswerSubmissionUpdateOne {
	mutation := newAnswerSubmissionMutation(c.config, OpUpdateOne, withAnswerSubmissionID(id))
	return &AnswerSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AnswerSubmission.
func (c *AnswerSubmissionClient) Delete() *AnswerSubmissionDelete {
	mutation := newAnswerSubmissionMutation(c.config, OpDelete)
	return &AnswerSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnswerSubmissionClient) DeleteOne(as *AnswerSubmission) *AnswerSubmissionDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnswerSubmissionClient) DeleteOneID(id uint64) *AnswerSubmissionDeleteOne {
	builder := c.Delete().Where(answersubmission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnswerSubmissionDeleteOne{builder}
}

// Query returns a query builder for AnswerSubmission.
func (c *AnswerSubmissionClient) Query() *AnswerSubmissionQuery {
	return &AnswerSubmissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnswerSubmission},
		inters: c.Interceptors(),
	}
}

// Get returns a AnswerSubmission entity by its id.
func (c *AnswerSubmissionClient) Get(ctx context.Context, id uint64) (*AnswerSubmission, error) {
	return c.Query().Where(answersubmission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnswerSubmissionClient) GetX(ctx context.Context, id uint64) *AnswerSubmission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubmissionAttempt queries the submission_attempt edge of a AnswerSubmission.
func (c *AnswerSubmissionClient) QuerySubmissionAttempt(as *AnswerSubmission) *SubmissionAttemptQuery {
	query := (&SubmissionAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answersubmission.Table, answersubmission.FieldID, id),
			sqlgraph.To(submissionattempt.Table, submissionattempt.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, answersubmission.SubmissionAttemptTable, answersubmission.SubmissionAttemptColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnswerSubmissionClient) Hooks() []Hook {
	return c.hooks.AnswerSubmission
}

// Interceptors returns the client interceptors.
func (c *AnswerSubmissionClient) Interceptors() []Interceptor {
	return c.inters.AnswerSubmission
}

func (c *AnswerSubmissionClient) mutate(ctx context.Context, m *AnswerSubmissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnswerSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnswerSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnswerSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnswerSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AnswerSubmission mutation op: %q", m.Op())
	}
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `question.Intercept(f(g(h())))`.
func (c *QuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Question = append(c.inters.Question, interceptors...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionClient) MapCreateBulk(slice any, setFunc func(*QuestionCreate, int)) *QuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCreateBulk{err: fmt.Errorf("calling to QuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id uint64) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id uint64) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id uint64) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id uint64) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScenario queries the scenario edge of a Question.
func (c *QuestionClient) QueryScenario(q *Question) *ScenarioQuery {
	query := (&ScenarioClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(scenario.Table, scenario.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.ScenarioTable, question.ScenarioColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// Interceptors returns the client interceptors.
func (c *QuestionClient) Interceptors() []Interceptor {
	return c.inters.Question
}

func (c *QuestionClient) mutate(ctx context.Context, m *QuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Question mutation op: %q", m.Op())
	}
}

// ScenarioClient is a client for the Scenario schema.
type ScenarioClient struct {
	config
}

// NewScenarioClient returns a client for the Scenario from the given config.
func NewScenarioClient(c config) *ScenarioClient {
	return &ScenarioClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenario.Hooks(f(g(h())))`.
func (c *ScenarioClient) Use(hooks ...Hook) {
	c.hooks.Scenario = append(c.hooks.Scenario, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenario.Intercept(f(g(h())))`.
func (c *ScenarioClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scenario = append(c.inters.Scenario, interceptors...)
}

// Create returns a builder for creating a Scenario entity.
func (c *ScenarioClient) Create() *ScenarioCreate {
	mutation := newScenarioMutation(c.config, OpCreate)
	return &ScenarioCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scenario entities.
func (c *ScenarioClient) CreateBulk(builders ...*ScenarioCreate) *ScenarioCreateBulk {
	return &ScenarioCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenarioClient) MapCreateBulk(slice any, setFunc func(*ScenarioCreate, int)) *ScenarioCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenarioCreateBulk{err: fmt.Errorf("calling to ScenarioClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenarioCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenarioCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scenario.
func (c *ScenarioClient) Update() *ScenarioUpdate {
	mutation := newScenarioMutation(c.config, OpUpdate)
	return &ScenarioUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenarioClient) UpdateOne(s *Scenario) *ScenarioUpdateOne {
	mutation := newScenarioMutation(c.config, OpUpdateOne, withScenario(s))
	return &ScenarioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenarioClient) UpdateOneID(id uint64) *ScenarioUpdateOne {
	mutation := newScenarioMutation(c.config, OpUpdateOne, withScenarioID(id))
	return &ScenarioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scenario.
func (c *ScenarioClient) Delete() *ScenarioDelete {
	mutation := newScenarioMutation(c.config, OpDelete)
	return &ScenarioDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenarioClient) DeleteOne(s *Scenario) *ScenarioDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenarioClient) DeleteOneID(id uint64) *ScenarioDeleteOne {
	builder := c.Delete().Where(scenario.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenarioDeleteOne{builder}
}

// Query returns a query builder for Scenario.
func (c *ScenarioClient) Query() *ScenarioQuery {
	return &ScenarioQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenario},
		inters: c.Interceptors(),
	}
}

// Get returns a Scenario entity by its id.
func (c *ScenarioClient) Get(ctx context.Context, id uint64) (*Scenario, error) {
	return c.Query().Where(scenario.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenarioClient) GetX(ctx context.Context, id uint64) *Scenario {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestions queries the questions edge of a Scenario.
func (c *ScenarioClient) QueryQuestions(s *Scenario) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenario.Table, scenario.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenario.QuestionsTable, scenario.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCandidates queries the candidates edge of a Scenario.
func (c *ScenarioClient) QueryCandidates(s *Scenario) *ScenarioCandidateQuery {
	query := (&ScenarioCandidateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenario.Table, scenario.FieldID, id),
			sqlgraph.To(scenariocandidate.Table, scenariocandidate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenario.CandidatesTable, scenario.CandidatesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFavorites queries the favorites edge of a Scenario.
func (c *ScenarioClient) QueryFavorites(s *Scenario) *ScenarioFavoriteQuery {
	query := (&ScenarioFavoriteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenario.Table, scenario.FieldID, id),
			sqlgraph.To(scenariofavorite.Table, scenariofavorite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenario.FavoritesTable, scenario.FavoritesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryField queries the field edge of a Scenario.
func (c *ScenarioClient) QueryField(s *Scenario) *ScenarioFieldQuery {
	query := (&ScenarioFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenario.Table, scenario.FieldID, id),
			sqlgraph.To(scenariofield.Table, scenariofield.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, scenario.FieldTable, scenario.FieldPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScenarioClient) Hooks() []Hook {
	return c.hooks.Scenario
}

// Interceptors returns the client interceptors.
func (c *ScenarioClient) Interceptors() []Interceptor {
	return c.inters.Scenario
}

func (c *ScenarioClient) mutate(ctx context.Context, m *ScenarioMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenarioCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenarioUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenarioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenarioDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scenario mutation op: %q", m.Op())
	}
}

// ScenarioCandidateClient is a client for the ScenarioCandidate schema.
type ScenarioCandidateClient struct {
	config
}

// NewScenarioCandidateClient returns a client for the ScenarioCandidate from the given config.
func NewScenarioCandidateClient(c config) *ScenarioCandidateClient {
	return &ScenarioCandidateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenariocandidate.Hooks(f(g(h())))`.
func (c *ScenarioCandidateClient) Use(hooks ...Hook) {
	c.hooks.ScenarioCandidate = append(c.hooks.ScenarioCandidate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenariocandidate.Intercept(f(g(h())))`.
func (c *ScenarioCandidateClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScenarioCandidate = append(c.inters.ScenarioCandidate, interceptors...)
}

// Create returns a builder for creating a ScenarioCandidate entity.
func (c *ScenarioCandidateClient) Create() *ScenarioCandidateCreate {
	mutation := newScenarioCandidateMutation(c.config, OpCreate)
	return &ScenarioCandidateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScenarioCandidate entities.
func (c *ScenarioCandidateClient) CreateBulk(builders ...*ScenarioCandidateCreate) *ScenarioCandidateCreateBulk {
	return &ScenarioCandidateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenarioCandidateClient) MapCreateBulk(slice any, setFunc func(*ScenarioCandidateCreate, int)) *ScenarioCandidateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenarioCandidateCreateBulk{err: fmt.Errorf("calling to ScenarioCandidateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenarioCandidateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenarioCandidateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScenarioCandidate.
func (c *ScenarioCandidateClient) Update() *ScenarioCandidateUpdate {
	mutation := newScenarioCandidateMutation(c.config, OpUpdate)
	return &ScenarioCandidateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenarioCandidateClient) UpdateOne(sc *ScenarioCandidate) *ScenarioCandidateUpdateOne {
	mutation := newScenarioCandidateMutation(c.config, OpUpdateOne, withScenarioCandidate(sc))
	return &ScenarioCandidateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenarioCandidateClient) UpdateOneID(id uint64) *ScenarioCandidateUpdateOne {
	mutation := newScenarioCandidateMutation(c.config, OpUpdateOne, withScenarioCandidateID(id))
	return &ScenarioCandidateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScenarioCandidate.
func (c *ScenarioCandidateClient) Delete() *ScenarioCandidateDelete {
	mutation := newScenarioCandidateMutation(c.config, OpDelete)
	return &ScenarioCandidateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenarioCandidateClient) DeleteOne(sc *ScenarioCandidate) *ScenarioCandidateDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenarioCandidateClient) DeleteOneID(id uint64) *ScenarioCandidateDeleteOne {
	builder := c.Delete().Where(scenariocandidate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenarioCandidateDeleteOne{builder}
}

// Query returns a query builder for ScenarioCandidate.
func (c *ScenarioCandidateClient) Query() *ScenarioCandidateQuery {
	return &ScenarioCandidateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenarioCandidate},
		inters: c.Interceptors(),
	}
}

// Get returns a ScenarioCandidate entity by its id.
func (c *ScenarioCandidateClient) Get(ctx context.Context, id uint64) (*ScenarioCandidate, error) {
	return c.Query().Where(scenariocandidate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenarioCandidateClient) GetX(ctx context.Context, id uint64) *ScenarioCandidate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScenario queries the scenario edge of a ScenarioCandidate.
func (c *ScenarioCandidateClient) QueryScenario(sc *ScenarioCandidate) *ScenarioQuery {
	query := (&ScenarioClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenariocandidate.Table, scenariocandidate.FieldID, id),
			sqlgraph.To(scenario.Table, scenario.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scenariocandidate.ScenarioTable, scenariocandidate.ScenarioColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttempts queries the attempts edge of a ScenarioCandidate.
func (c *ScenarioCandidateClient) QueryAttempts(sc *ScenarioCandidate) *SubmissionAttemptQuery {
	query := (&SubmissionAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenariocandidate.Table, scenariocandidate.FieldID, id),
			sqlgraph.To(submissionattempt.Table, submissionattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenariocandidate.AttemptsTable, scenariocandidate.AttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScenarioCandidateClient) Hooks() []Hook {
	return c.hooks.ScenarioCandidate
}

// Interceptors returns the client interceptors.
func (c *ScenarioCandidateClient) Interceptors() []Interceptor {
	return c.inters.ScenarioCandidate
}

func (c *ScenarioCandidateClient) mutate(ctx context.Context, m *ScenarioCandidateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenarioCandidateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenarioCandidateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenarioCandidateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenarioCandidateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScenarioCandidate mutation op: %q", m.Op())
	}
}

// ScenarioFavoriteClient is a client for the ScenarioFavorite schema.
type ScenarioFavoriteClient struct {
	config
}

// NewScenarioFavoriteClient returns a client for the ScenarioFavorite from the given config.
func NewScenarioFavoriteClient(c config) *ScenarioFavoriteClient {
	return &ScenarioFavoriteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenariofavorite.Hooks(f(g(h())))`.
func (c *ScenarioFavoriteClient) Use(hooks ...Hook) {
	c.hooks.ScenarioFavorite = append(c.hooks.ScenarioFavorite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenariofavorite.Intercept(f(g(h())))`.
func (c *ScenarioFavoriteClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScenarioFavorite = append(c.inters.ScenarioFavorite, interceptors...)
}

// Create returns a builder for creating a ScenarioFavorite entity.
func (c *ScenarioFavoriteClient) Create() *ScenarioFavoriteCreate {
	mutation := newScenarioFavoriteMutation(c.config, OpCreate)
	return &ScenarioFavoriteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScenarioFavorite entities.
func (c *ScenarioFavoriteClient) CreateBulk(builders ...*ScenarioFavoriteCreate) *ScenarioFavoriteCreateBulk {
	return &ScenarioFavoriteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenarioFavoriteClient) MapCreateBulk(slice any, setFunc func(*ScenarioFavoriteCreate, int)) *ScenarioFavoriteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenarioFavoriteCreateBulk{err: fmt.Errorf("calling to ScenarioFavoriteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenarioFavoriteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenarioFavoriteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScenarioFavorite.
func (c *ScenarioFavoriteClient) Update() *ScenarioFavoriteUpdate {
	mutation := newScenarioFavoriteMutation(c.config, OpUpdate)
	return &ScenarioFavoriteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenarioFavoriteClient) UpdateOne(sf *ScenarioFavorite) *ScenarioFavoriteUpdateOne {
	mutation := newScenarioFavoriteMutation(c.config, OpUpdateOne, withScenarioFavorite(sf))
	return &ScenarioFavoriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenarioFavoriteClient) UpdateOneID(id uint64) *ScenarioFavoriteUpdateOne {
	mutation := newScenarioFavoriteMutation(c.config, OpUpdateOne, withScenarioFavoriteID(id))
	return &ScenarioFavoriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScenarioFavorite.
func (c *ScenarioFavoriteClient) Delete() *ScenarioFavoriteDelete {
	mutation := newScenarioFavoriteMutation(c.config, OpDelete)
	return &ScenarioFavoriteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenarioFavoriteClient) DeleteOne(sf *ScenarioFavorite) *ScenarioFavoriteDeleteOne {
	return c.DeleteOneID(sf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenarioFavoriteClient) DeleteOneID(id uint64) *ScenarioFavoriteDeleteOne {
	builder := c.Delete().Where(scenariofavorite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenarioFavoriteDeleteOne{builder}
}

// Query returns a query builder for ScenarioFavorite.
func (c *ScenarioFavoriteClient) Query() *ScenarioFavoriteQuery {
	return &ScenarioFavoriteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenarioFavorite},
		inters: c.Interceptors(),
	}
}

// Get returns a ScenarioFavorite entity by its id.
func (c *ScenarioFavoriteClient) Get(ctx context.Context, id uint64) (*ScenarioFavorite, error) {
	return c.Query().Where(scenariofavorite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenarioFavoriteClient) GetX(ctx context.Context, id uint64) *ScenarioFavorite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySenario queries the senario edge of a ScenarioFavorite.
func (c *ScenarioFavoriteClient) QuerySenario(sf *ScenarioFavorite) *ScenarioQuery {
	query := (&ScenarioClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenariofavorite.Table, scenariofavorite.FieldID, id),
			sqlgraph.To(scenario.Table, scenario.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scenariofavorite.SenarioTable, scenariofavorite.SenarioColumn),
		)
		fromV = sqlgraph.Neighbors(sf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScenarioFavoriteClient) Hooks() []Hook {
	return c.hooks.ScenarioFavorite
}

// Interceptors returns the client interceptors.
func (c *ScenarioFavoriteClient) Interceptors() []Interceptor {
	return c.inters.ScenarioFavorite
}

func (c *ScenarioFavoriteClient) mutate(ctx context.Context, m *ScenarioFavoriteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenarioFavoriteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenarioFavoriteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenarioFavoriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenarioFavoriteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScenarioFavorite mutation op: %q", m.Op())
	}
}

// ScenarioFieldClient is a client for the ScenarioField schema.
type ScenarioFieldClient struct {
	config
}

// NewScenarioFieldClient returns a client for the ScenarioField from the given config.
func NewScenarioFieldClient(c config) *ScenarioFieldClient {
	return &ScenarioFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenariofield.Hooks(f(g(h())))`.
func (c *ScenarioFieldClient) Use(hooks ...Hook) {
	c.hooks.ScenarioField = append(c.hooks.ScenarioField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenariofield.Intercept(f(g(h())))`.
func (c *ScenarioFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScenarioField = append(c.inters.ScenarioField, interceptors...)
}

// Create returns a builder for creating a ScenarioField entity.
func (c *ScenarioFieldClient) Create() *ScenarioFieldCreate {
	mutation := newScenarioFieldMutation(c.config, OpCreate)
	return &ScenarioFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScenarioField entities.
func (c *ScenarioFieldClient) CreateBulk(builders ...*ScenarioFieldCreate) *ScenarioFieldCreateBulk {
	return &ScenarioFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenarioFieldClient) MapCreateBulk(slice any, setFunc func(*ScenarioFieldCreate, int)) *ScenarioFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenarioFieldCreateBulk{err: fmt.Errorf("calling to ScenarioFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenarioFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenarioFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScenarioField.
func (c *ScenarioFieldClient) Update() *ScenarioFieldUpdate {
	mutation := newScenarioFieldMutation(c.config, OpUpdate)
	return &ScenarioFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenarioFieldClient) UpdateOne(sf *ScenarioField) *ScenarioFieldUpdateOne {
	mutation := newScenarioFieldMutation(c.config, OpUpdateOne, withScenarioField(sf))
	return &ScenarioFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenarioFieldClient) UpdateOneID(id uint64) *ScenarioFieldUpdateOne {
	mutation := newScenarioFieldMutation(c.config, OpUpdateOne, withScenarioFieldID(id))
	return &ScenarioFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScenarioField.
func (c *ScenarioFieldClient) Delete() *ScenarioFieldDelete {
	mutation := newScenarioFieldMutation(c.config, OpDelete)
	return &ScenarioFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenarioFieldClient) DeleteOne(sf *ScenarioField) *ScenarioFieldDeleteOne {
	return c.DeleteOneID(sf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenarioFieldClient) DeleteOneID(id uint64) *ScenarioFieldDeleteOne {
	builder := c.Delete().Where(scenariofield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenarioFieldDeleteOne{builder}
}

// Query returns a query builder for ScenarioField.
func (c *ScenarioFieldClient) Query() *ScenarioFieldQuery {
	return &ScenarioFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenarioField},
		inters: c.Interceptors(),
	}
}

// Get returns a ScenarioField entity by its id.
func (c *ScenarioFieldClient) Get(ctx context.Context, id uint64) (*ScenarioField, error) {
	return c.Query().Where(scenariofield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenarioFieldClient) GetX(ctx context.Context, id uint64) *ScenarioField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySenarios queries the senarios edge of a ScenarioField.
func (c *ScenarioFieldClient) QuerySenarios(sf *ScenarioField) *ScenarioQuery {
	query := (&ScenarioClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenariofield.Table, scenariofield.FieldID, id),
			sqlgraph.To(scenario.Table, scenario.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scenariofield.SenariosTable, scenariofield.SenariosPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScenarioFieldClient) Hooks() []Hook {
	return c.hooks.ScenarioField
}

// Interceptors returns the client interceptors.
func (c *ScenarioFieldClient) Interceptors() []Interceptor {
	return c.inters.ScenarioField
}

func (c *ScenarioFieldClient) mutate(ctx context.Context, m *ScenarioFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenarioFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenarioFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenarioFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenarioFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScenarioField mutation op: %q", m.Op())
	}
}

// SubmissionAttemptClient is a client for the SubmissionAttempt schema.
type SubmissionAttemptClient struct {
	config
}

// NewSubmissionAttemptClient returns a client for the SubmissionAttempt from the given config.
func NewSubmissionAttemptClient(c config) *SubmissionAttemptClient {
	return &SubmissionAttemptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `submissionattempt.Hooks(f(g(h())))`.
func (c *SubmissionAttemptClient) Use(hooks ...Hook) {
	c.hooks.SubmissionAttempt = append(c.hooks.SubmissionAttempt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `submissionattempt.Intercept(f(g(h())))`.
func (c *SubmissionAttemptClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubmissionAttempt = append(c.inters.SubmissionAttempt, interceptors...)
}

// Create returns a builder for creating a SubmissionAttempt entity.
func (c *SubmissionAttemptClient) Create() *SubmissionAttemptCreate {
	mutation := newSubmissionAttemptMutation(c.config, OpCreate)
	return &SubmissionAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubmissionAttempt entities.
func (c *SubmissionAttemptClient) CreateBulk(builders ...*SubmissionAttemptCreate) *SubmissionAttemptCreateBulk {
	return &SubmissionAttemptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubmissionAttemptClient) MapCreateBulk(slice any, setFunc func(*SubmissionAttemptCreate, int)) *SubmissionAttemptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubmissionAttemptCreateBulk{err: fmt.Errorf("calling to SubmissionAttemptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubmissionAttemptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubmissionAttemptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubmissionAttempt.
func (c *SubmissionAttemptClient) Update() *SubmissionAttemptUpdate {
	mutation := newSubmissionAttemptMutation(c.config, OpUpdate)
	return &SubmissionAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubmissionAttemptClient) UpdateOne(sa *SubmissionAttempt) *SubmissionAttemptUpdateOne {
	mutation := newSubmissionAttemptMutation(c.config, OpUpdateOne, withSubmissionAttempt(sa))
	return &SubmissionAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubmissionAttemptClient) UpdateOneID(id uint64) *SubmissionAttemptUpdateOne {
	mutation := newSubmissionAttemptMutation(c.config, OpUpdateOne, withSubmissionAttemptID(id))
	return &SubmissionAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubmissionAttempt.
func (c *SubmissionAttemptClient) Delete() *SubmissionAttemptDelete {
	mutation := newSubmissionAttemptMutation(c.config, OpDelete)
	return &SubmissionAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubmissionAttemptClient) DeleteOne(sa *SubmissionAttempt) *SubmissionAttemptDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubmissionAttemptClient) DeleteOneID(id uint64) *SubmissionAttemptDeleteOne {
	builder := c.Delete().Where(submissionattempt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubmissionAttemptDeleteOne{builder}
}

// Query returns a query builder for SubmissionAttempt.
func (c *SubmissionAttemptClient) Query() *SubmissionAttemptQuery {
	return &SubmissionAttemptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubmissionAttempt},
		inters: c.Interceptors(),
	}
}

// Get returns a SubmissionAttempt entity by its id.
func (c *SubmissionAttemptClient) Get(ctx context.Context, id uint64) (*SubmissionAttempt, error) {
	return c.Query().Where(submissionattempt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubmissionAttemptClient) GetX(ctx context.Context, id uint64) *SubmissionAttempt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScenarioCandidate queries the scenario_candidate edge of a SubmissionAttempt.
func (c *SubmissionAttemptClient) QueryScenarioCandidate(sa *SubmissionAttempt) *ScenarioCandidateQuery {
	query := (&ScenarioCandidateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(submissionattempt.Table, submissionattempt.FieldID, id),
			sqlgraph.To(scenariocandidate.Table, scenariocandidate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, submissionattempt.ScenarioCandidateTable, submissionattempt.ScenarioCandidateColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnswers queries the answers edge of a SubmissionAttempt.
func (c *SubmissionAttemptClient) QueryAnswers(sa *SubmissionAttempt) *AnswerSubmissionQuery {
	query := (&AnswerSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(submissionattempt.Table, submissionattempt.FieldID, id),
			sqlgraph.To(answersubmission.Table, answersubmission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, submissionattempt.AnswersTable, submissionattempt.AnswersColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubmissionAttemptClient) Hooks() []Hook {
	return c.hooks.SubmissionAttempt
}

// Interceptors returns the client interceptors.
func (c *SubmissionAttemptClient) Interceptors() []Interceptor {
	return c.inters.SubmissionAttempt
}

func (c *SubmissionAttemptClient) mutate(ctx context.Context, m *SubmissionAttemptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubmissionAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubmissionAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubmissionAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubmissionAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SubmissionAttempt mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AnswerSubmission, Question, Scenario, ScenarioCandidate, ScenarioFavorite,
		ScenarioField, SubmissionAttempt []ent.Hook
	}
	inters struct {
		AnswerSubmission, Question, Scenario, ScenarioCandidate, ScenarioFavorite,
		ScenarioField, SubmissionAttempt []ent.Interceptor
	}
)
