// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: Ekko/api/ekko.proto

package ekko

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SortMethod with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SortMethod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SortMethod with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SortMethodMultiError, or
// nil if none found.
func (m *SortMethod) ValidateAll() error {
	return m.validate(true)
}

func (m *SortMethod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := SortMethodValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	if len(errors) > 0 {
		return SortMethodMultiError(errors)
	}

	return nil
}

// SortMethodMultiError is an error wrapping multiple validation errors
// returned by SortMethod.ValidateAll() if the designated constraints aren't met.
type SortMethodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SortMethodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SortMethodMultiError) AllErrors() []error { return m }

// SortMethodValidationError is the validation error returned by
// SortMethod.Validate if the designated constraints aren't met.
type SortMethodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SortMethodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SortMethodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SortMethodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SortMethodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SortMethodValidationError) ErrorName() string { return "SortMethodValidationError" }

// Error satisfies the builtin error interface
func (e SortMethodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSortMethod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SortMethodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SortMethodValidationError{}

// Validate checks the field values on TestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestRequestMultiError, or
// nil if none found.
func (m *TestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestRequestMultiError(errors)
	}

	return nil
}

// TestRequestMultiError is an error wrapping multiple validation errors
// returned by TestRequest.ValidateAll() if the designated constraints aren't met.
type TestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRequestMultiError) AllErrors() []error { return m }

// TestRequestValidationError is the validation error returned by
// TestRequest.Validate if the designated constraints aren't met.
type TestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRequestValidationError) ErrorName() string { return "TestRequestValidationError" }

// Error satisfies the builtin error interface
func (e TestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRequestValidationError{}

// Validate checks the field values on TestResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestResponseMultiError, or
// nil if none found.
func (m *TestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return TestResponseMultiError(errors)
	}

	return nil
}

// TestResponseMultiError is an error wrapping multiple validation errors
// returned by TestResponse.ValidateAll() if the designated constraints aren't met.
type TestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResponseMultiError) AllErrors() []error { return m }

// TestResponseValidationError is the validation error returned by
// TestResponse.Validate if the designated constraints aren't met.
type TestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResponseValidationError) ErrorName() string { return "TestResponseValidationError" }

// Error satisfies the builtin error interface
func (e TestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResponseValidationError{}

// Validate checks the field values on Answer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Answer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Answer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AnswerMultiError, or nil if none found.
func (m *Answer) ValidateAll() error {
	return m.validate(true)
}

func (m *Answer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuestionId

	// no validation rules for Answer

	// no validation rules for Relevance

	// no validation rules for ClarityCompleteness

	// no validation rules for Accuracy

	// no validation rules for Overall

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetBaseData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnswerValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnswerValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnswerValidationError{
				field:  "BaseData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AnswerMultiError(errors)
	}

	return nil
}

// AnswerMultiError is an error wrapping multiple validation errors returned by
// Answer.ValidateAll() if the designated constraints aren't met.
type AnswerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnswerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnswerMultiError) AllErrors() []error { return m }

// AnswerValidationError is the validation error returned by Answer.Validate if
// the designated constraints aren't met.
type AnswerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnswerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnswerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnswerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnswerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnswerValidationError) ErrorName() string { return "AnswerValidationError" }

// Error satisfies the builtin error interface
func (e AnswerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnswer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnswerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnswerValidationError{}

// Validate checks the field values on Attempt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Attempt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Attempt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AttemptMultiError, or nil if none found.
func (m *Attempt) ValidateAll() error {
	return m.validate(true)
}

func (m *Attempt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ScenarioId

	for idx, item := range m.GetAnswers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AttemptValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AttemptValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AttemptValidationError{
					field:  fmt.Sprintf("Answers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetBaseData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AttemptValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AttemptValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AttemptValidationError{
				field:  "BaseData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttemptNumber

	if len(errors) > 0 {
		return AttemptMultiError(errors)
	}

	return nil
}

// AttemptMultiError is an error wrapping multiple validation errors returned
// by Attempt.ValidateAll() if the designated constraints aren't met.
type AttemptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttemptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttemptMultiError) AllErrors() []error { return m }

// AttemptValidationError is the validation error returned by Attempt.Validate
// if the designated constraints aren't met.
type AttemptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttemptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttemptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttemptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttemptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttemptValidationError) ErrorName() string { return "AttemptValidationError" }

// Error satisfies the builtin error interface
func (e AttemptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttempt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttemptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttemptValidationError{}

// Validate checks the field values on Submission with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Submission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Submission with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubmissionMultiError, or
// nil if none found.
func (m *Submission) ValidateAll() error {
	return m.validate(true)
}

func (m *Submission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ScenarioId

	// no validation rules for CandidateId

	for idx, item := range m.GetAttempts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmissionValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmissionValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmissionValidationError{
					field:  fmt.Sprintf("Attempts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmissionMultiError(errors)
	}

	return nil
}

// SubmissionMultiError is an error wrapping multiple validation errors
// returned by Submission.ValidateAll() if the designated constraints aren't met.
type SubmissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmissionMultiError) AllErrors() []error { return m }

// SubmissionValidationError is the validation error returned by
// Submission.Validate if the designated constraints aren't met.
type SubmissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmissionValidationError) ErrorName() string { return "SubmissionValidationError" }

// Error satisfies the builtin error interface
func (e SubmissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmissionValidationError{}

// Validate checks the field values on BaseData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BaseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BaseData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BaseDataMultiError, or nil
// if none found.
func (m *BaseData) ValidateAll() error {
	return m.validate(true)
}

func (m *BaseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BaseDataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BaseDataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BaseDataValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BaseDataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BaseDataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BaseDataValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BaseDataMultiError(errors)
	}

	return nil
}

// BaseDataMultiError is an error wrapping multiple validation errors returned
// by BaseData.ValidateAll() if the designated constraints aren't met.
type BaseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BaseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BaseDataMultiError) AllErrors() []error { return m }

// BaseDataValidationError is the validation error returned by
// BaseData.Validate if the designated constraints aren't met.
type BaseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BaseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BaseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BaseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BaseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BaseDataValidationError) ErrorName() string { return "BaseDataValidationError" }

// Error satisfies the builtin error interface
func (e BaseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBaseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BaseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BaseDataValidationError{}

// Validate checks the field values on Field with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Field) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Field with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FieldMultiError, or nil if none found.
func (m *Field) ValidateAll() error {
	return m.validate(true)
}

func (m *Field) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetBaseData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FieldValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FieldValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FieldValidationError{
				field:  "BaseData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FieldMultiError(errors)
	}

	return nil
}

// FieldMultiError is an error wrapping multiple validation errors returned by
// Field.ValidateAll() if the designated constraints aren't met.
type FieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldMultiError) AllErrors() []error { return m }

// FieldValidationError is the validation error returned by Field.Validate if
// the designated constraints aren't met.
type FieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldValidationError) ErrorName() string { return "FieldValidationError" }

// Error satisfies the builtin error interface
func (e FieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldValidationError{}

// Validate checks the field values on Scenario with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Scenario) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scenario with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScenarioMultiError, or nil
// if none found.
func (m *Scenario) ValidateAll() error {
	return m.validate(true)
}

func (m *Scenario) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetBaseData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScenarioValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScenarioValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScenarioValidationError{
				field:  "BaseData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Rating

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScenarioValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScenarioValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScenarioValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalParticipant

	for idx, item := range m.GetQuestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScenarioValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScenarioValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScenarioValidationError{
					field:  fmt.Sprintf("Questions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ScenarioMultiError(errors)
	}

	return nil
}

// ScenarioMultiError is an error wrapping multiple validation errors returned
// by Scenario.ValidateAll() if the designated constraints aren't met.
type ScenarioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScenarioMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScenarioMultiError) AllErrors() []error { return m }

// ScenarioValidationError is the validation error returned by
// Scenario.Validate if the designated constraints aren't met.
type ScenarioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScenarioValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScenarioValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScenarioValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScenarioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScenarioValidationError) ErrorName() string { return "ScenarioValidationError" }

// Error satisfies the builtin error interface
func (e ScenarioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScenario.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScenarioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScenarioValidationError{}

// Validate checks the field values on Question with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Question) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Question with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuestionMultiError, or nil
// if none found.
func (m *Question) ValidateAll() error {
	return m.validate(true)
}

func (m *Question) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Criteria

	// no validation rules for Hint

	// no validation rules for Content

	if all {
		switch v := interface{}(m.GetBaseData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuestionValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuestionValidationError{
					field:  "BaseData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuestionValidationError{
				field:  "BaseData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QuestionMultiError(errors)
	}

	return nil
}

// QuestionMultiError is an error wrapping multiple validation errors returned
// by Question.ValidateAll() if the designated constraints aren't met.
type QuestionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuestionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuestionMultiError) AllErrors() []error { return m }

// QuestionValidationError is the validation error returned by
// Question.Validate if the designated constraints aren't met.
type QuestionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuestionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuestionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuestionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuestionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuestionValidationError) ErrorName() string { return "QuestionValidationError" }

// Error satisfies the builtin error interface
func (e QuestionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuestion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuestionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuestionValidationError{}

// Validate checks the field values on ListAllSubmissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAllSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAllSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAllSubmissionRequestMultiError, or nil if none found.
func (m *ListAllSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAllSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenarioId

	if m.GetPageIndex() < 0 {
		err := ListAllSubmissionRequestValidationError{
			field:  "PageIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 1 {
		err := ListAllSubmissionRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSortMethod() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAllSubmissionRequestValidationError{
						field:  fmt.Sprintf("SortMethod[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAllSubmissionRequestValidationError{
						field:  fmt.Sprintf("SortMethod[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAllSubmissionRequestValidationError{
					field:  fmt.Sprintf("SortMethod[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAllSubmissionRequestMultiError(errors)
	}

	return nil
}

// ListAllSubmissionRequestMultiError is an error wrapping multiple validation
// errors returned by ListAllSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAllSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAllSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAllSubmissionRequestMultiError) AllErrors() []error { return m }

// ListAllSubmissionRequestValidationError is the validation error returned by
// ListAllSubmissionRequest.Validate if the designated constraints aren't met.
type ListAllSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAllSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAllSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAllSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAllSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAllSubmissionRequestValidationError) ErrorName() string {
	return "ListAllSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAllSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAllSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAllSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAllSubmissionRequestValidationError{}

// Validate checks the field values on ListAllSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAllSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAllSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAllSubmissionResponseMultiError, or nil if none found.
func (m *ListAllSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAllSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubmissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAllSubmissionResponseValidationError{
						field:  fmt.Sprintf("Submissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAllSubmissionResponseValidationError{
						field:  fmt.Sprintf("Submissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAllSubmissionResponseValidationError{
					field:  fmt.Sprintf("Submissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for TotalPage

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAllSubmissionResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAllSubmissionResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAllSubmissionResponseValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAllSubmissionResponseMultiError(errors)
	}

	return nil
}

// ListAllSubmissionResponseMultiError is an error wrapping multiple validation
// errors returned by ListAllSubmissionResponse.ValidateAll() if the
// designated constraints aren't met.
type ListAllSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAllSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAllSubmissionResponseMultiError) AllErrors() []error { return m }

// ListAllSubmissionResponseValidationError is the validation error returned by
// ListAllSubmissionResponse.Validate if the designated constraints aren't met.
type ListAllSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAllSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAllSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAllSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAllSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAllSubmissionResponseValidationError) ErrorName() string {
	return "ListAllSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAllSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAllSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAllSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAllSubmissionResponseValidationError{}

// Validate checks the field values on ListAttemptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAttemptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAttemptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAttemptRequestMultiError, or nil if none found.
func (m *ListAttemptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAttemptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenarioId

	if m.GetPageIndex() < 0 {
		err := ListAttemptRequestValidationError{
			field:  "PageIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 1 {
		err := ListAttemptRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSortMethod() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAttemptRequestValidationError{
						field:  fmt.Sprintf("SortMethod[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAttemptRequestValidationError{
						field:  fmt.Sprintf("SortMethod[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAttemptRequestValidationError{
					field:  fmt.Sprintf("SortMethod[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAttemptRequestMultiError(errors)
	}

	return nil
}

// ListAttemptRequestMultiError is an error wrapping multiple validation errors
// returned by ListAttemptRequest.ValidateAll() if the designated constraints
// aren't met.
type ListAttemptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAttemptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAttemptRequestMultiError) AllErrors() []error { return m }

// ListAttemptRequestValidationError is the validation error returned by
// ListAttemptRequest.Validate if the designated constraints aren't met.
type ListAttemptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAttemptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAttemptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAttemptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAttemptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAttemptRequestValidationError) ErrorName() string {
	return "ListAttemptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAttemptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAttemptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAttemptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAttemptRequestValidationError{}

// Validate checks the field values on ListAttemptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAttemptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAttemptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAttemptResponseMultiError, or nil if none found.
func (m *ListAttemptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAttemptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAttempts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAttemptResponseValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAttemptResponseValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAttemptResponseValidationError{
					field:  fmt.Sprintf("Attempts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for TotalPage

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAttemptResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAttemptResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAttemptResponseValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAttemptResponseMultiError(errors)
	}

	return nil
}

// ListAttemptResponseMultiError is an error wrapping multiple validation
// errors returned by ListAttemptResponse.ValidateAll() if the designated
// constraints aren't met.
type ListAttemptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAttemptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAttemptResponseMultiError) AllErrors() []error { return m }

// ListAttemptResponseValidationError is the validation error returned by
// ListAttemptResponse.Validate if the designated constraints aren't met.
type ListAttemptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAttemptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAttemptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAttemptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAttemptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAttemptResponseValidationError) ErrorName() string {
	return "ListAttemptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAttemptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAttemptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAttemptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAttemptResponseValidationError{}

// Validate checks the field values on GetAttemptRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAttemptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAttemptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAttemptRequestMultiError, or nil if none found.
func (m *GetAttemptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAttemptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetAttemptRequestMultiError(errors)
	}

	return nil
}

// GetAttemptRequestMultiError is an error wrapping multiple validation errors
// returned by GetAttemptRequest.ValidateAll() if the designated constraints
// aren't met.
type GetAttemptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAttemptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAttemptRequestMultiError) AllErrors() []error { return m }

// GetAttemptRequestValidationError is the validation error returned by
// GetAttemptRequest.Validate if the designated constraints aren't met.
type GetAttemptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAttemptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAttemptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAttemptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAttemptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAttemptRequestValidationError) ErrorName() string {
	return "GetAttemptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAttemptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAttemptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAttemptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAttemptRequestValidationError{}

// Validate checks the field values on SubmitAnswerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitAnswerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitAnswerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitAnswerRequestMultiError, or nil if none found.
func (m *SubmitAnswerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitAnswerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenarioId

	for idx, item := range m.GetAnswers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitAnswerRequestValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitAnswerRequestValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitAnswerRequestValidationError{
					field:  fmt.Sprintf("Answers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmitAnswerRequestMultiError(errors)
	}

	return nil
}

// SubmitAnswerRequestMultiError is an error wrapping multiple validation
// errors returned by SubmitAnswerRequest.ValidateAll() if the designated
// constraints aren't met.
type SubmitAnswerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitAnswerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitAnswerRequestMultiError) AllErrors() []error { return m }

// SubmitAnswerRequestValidationError is the validation error returned by
// SubmitAnswerRequest.Validate if the designated constraints aren't met.
type SubmitAnswerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitAnswerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitAnswerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitAnswerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitAnswerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitAnswerRequestValidationError) ErrorName() string {
	return "SubmitAnswerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitAnswerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitAnswerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitAnswerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitAnswerRequestValidationError{}

// Validate checks the field values on SubmitAnswerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitAnswerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitAnswerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitAnswerResponseMultiError, or nil if none found.
func (m *SubmitAnswerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitAnswerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAttempt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitAnswerResponseValidationError{
					field:  "Attempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitAnswerResponseValidationError{
					field:  "Attempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttempt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitAnswerResponseValidationError{
				field:  "Attempt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubmitAnswerResponseMultiError(errors)
	}

	return nil
}

// SubmitAnswerResponseMultiError is an error wrapping multiple validation
// errors returned by SubmitAnswerResponse.ValidateAll() if the designated
// constraints aren't met.
type SubmitAnswerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitAnswerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitAnswerResponseMultiError) AllErrors() []error { return m }

// SubmitAnswerResponseValidationError is the validation error returned by
// SubmitAnswerResponse.Validate if the designated constraints aren't met.
type SubmitAnswerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitAnswerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitAnswerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitAnswerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitAnswerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitAnswerResponseValidationError) ErrorName() string {
	return "SubmitAnswerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitAnswerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitAnswerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitAnswerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitAnswerResponseValidationError{}

// Validate checks the field values on GetAttemptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAttemptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAttemptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAttemptResponseMultiError, or nil if none found.
func (m *GetAttemptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAttemptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAttempt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAttemptResponseValidationError{
					field:  "Attempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAttemptResponseValidationError{
					field:  "Attempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttempt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAttemptResponseValidationError{
				field:  "Attempt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAttemptResponseMultiError(errors)
	}

	return nil
}

// GetAttemptResponseMultiError is an error wrapping multiple validation errors
// returned by GetAttemptResponse.ValidateAll() if the designated constraints
// aren't met.
type GetAttemptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAttemptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAttemptResponseMultiError) AllErrors() []error { return m }

// GetAttemptResponseValidationError is the validation error returned by
// GetAttemptResponse.Validate if the designated constraints aren't met.
type GetAttemptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAttemptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAttemptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAttemptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAttemptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAttemptResponseValidationError) ErrorName() string {
	return "GetAttemptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAttemptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAttemptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAttemptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAttemptResponseValidationError{}

// Validate checks the field values on CreateFieldResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFieldResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFieldResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFieldResponseMultiError, or nil if none found.
func (m *CreateFieldResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFieldResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetField()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFieldResponseValidationError{
					field:  "Field",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFieldResponseValidationError{
					field:  "Field",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetField()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFieldResponseValidationError{
				field:  "Field",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateFieldResponseMultiError(errors)
	}

	return nil
}

// CreateFieldResponseMultiError is an error wrapping multiple validation
// errors returned by CreateFieldResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateFieldResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFieldResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFieldResponseMultiError) AllErrors() []error { return m }

// CreateFieldResponseValidationError is the validation error returned by
// CreateFieldResponse.Validate if the designated constraints aren't met.
type CreateFieldResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFieldResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFieldResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFieldResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFieldResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFieldResponseValidationError) ErrorName() string {
	return "CreateFieldResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFieldResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFieldResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFieldResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFieldResponseValidationError{}

// Validate checks the field values on CreateFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFieldRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFieldRequestMultiError, or nil if none found.
func (m *CreateFieldRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFieldRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return CreateFieldRequestMultiError(errors)
	}

	return nil
}

// CreateFieldRequestMultiError is an error wrapping multiple validation errors
// returned by CreateFieldRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateFieldRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFieldRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFieldRequestMultiError) AllErrors() []error { return m }

// CreateFieldRequestValidationError is the validation error returned by
// CreateFieldRequest.Validate if the designated constraints aren't met.
type CreateFieldRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFieldRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFieldRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFieldRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFieldRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFieldRequestValidationError) ErrorName() string {
	return "CreateFieldRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFieldRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFieldRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFieldRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFieldRequestValidationError{}

// Validate checks the field values on UpdateFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateFieldRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateFieldRequestMultiError, or nil if none found.
func (m *UpdateFieldRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFieldRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return UpdateFieldRequestMultiError(errors)
	}

	return nil
}

// UpdateFieldRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateFieldRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateFieldRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFieldRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFieldRequestMultiError) AllErrors() []error { return m }

// UpdateFieldRequestValidationError is the validation error returned by
// UpdateFieldRequest.Validate if the designated constraints aren't met.
type UpdateFieldRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFieldRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFieldRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFieldRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFieldRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFieldRequestValidationError) ErrorName() string {
	return "UpdateFieldRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFieldRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFieldRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFieldRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFieldRequestValidationError{}

// Validate checks the field values on DeleteFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFieldRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFieldRequestMultiError, or nil if none found.
func (m *DeleteFieldRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFieldRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteFieldRequestMultiError(errors)
	}

	return nil
}

// DeleteFieldRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteFieldRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteFieldRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFieldRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFieldRequestMultiError) AllErrors() []error { return m }

// DeleteFieldRequestValidationError is the validation error returned by
// DeleteFieldRequest.Validate if the designated constraints aren't met.
type DeleteFieldRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFieldRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFieldRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFieldRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFieldRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFieldRequestValidationError) ErrorName() string {
	return "DeleteFieldRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFieldRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFieldRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFieldRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFieldRequestValidationError{}

// Validate checks the field values on ListFieldRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFieldRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFieldRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFieldRequestMultiError, or nil if none found.
func (m *ListFieldRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFieldRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSortMethods() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFieldRequestValidationError{
						field:  fmt.Sprintf("SortMethods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFieldRequestValidationError{
						field:  fmt.Sprintf("SortMethods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFieldRequestValidationError{
					field:  fmt.Sprintf("SortMethods[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetPageIndex() < 0 {
		err := ListFieldRequestValidationError{
			field:  "PageIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 1 {
		err := ListFieldRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.SearchContent != nil {
		// no validation rules for SearchContent
	}

	if len(errors) > 0 {
		return ListFieldRequestMultiError(errors)
	}

	return nil
}

// ListFieldRequestMultiError is an error wrapping multiple validation errors
// returned by ListFieldRequest.ValidateAll() if the designated constraints
// aren't met.
type ListFieldRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFieldRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFieldRequestMultiError) AllErrors() []error { return m }

// ListFieldRequestValidationError is the validation error returned by
// ListFieldRequest.Validate if the designated constraints aren't met.
type ListFieldRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFieldRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFieldRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFieldRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFieldRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFieldRequestValidationError) ErrorName() string { return "ListFieldRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListFieldRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFieldRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFieldRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFieldRequestValidationError{}

// Validate checks the field values on ListFieldResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFieldResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFieldResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFieldResponseMultiError, or nil if none found.
func (m *ListFieldResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFieldResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFieldResponseValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFieldResponseValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFieldResponseValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for TotalPage

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFieldResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFieldResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFieldResponseValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFieldResponseMultiError(errors)
	}

	return nil
}

// ListFieldResponseMultiError is an error wrapping multiple validation errors
// returned by ListFieldResponse.ValidateAll() if the designated constraints
// aren't met.
type ListFieldResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFieldResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFieldResponseMultiError) AllErrors() []error { return m }

// ListFieldResponseValidationError is the validation error returned by
// ListFieldResponse.Validate if the designated constraints aren't met.
type ListFieldResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFieldResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFieldResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFieldResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFieldResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFieldResponseValidationError) ErrorName() string {
	return "ListFieldResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFieldResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFieldResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFieldResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFieldResponseValidationError{}

// Validate checks the field values on CreateScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateScenarioRequestMultiError, or nil if none found.
func (m *CreateScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	for idx, item := range m.GetQuestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateScenarioRequestValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateScenarioRequestValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateScenarioRequestValidationError{
					field:  fmt.Sprintf("Questions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateScenarioRequestMultiError(errors)
	}

	return nil
}

// CreateScenarioRequestMultiError is an error wrapping multiple validation
// errors returned by CreateScenarioRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateScenarioRequestMultiError) AllErrors() []error { return m }

// CreateScenarioRequestValidationError is the validation error returned by
// CreateScenarioRequest.Validate if the designated constraints aren't met.
type CreateScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateScenarioRequestValidationError) ErrorName() string {
	return "CreateScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateScenarioRequestValidationError{}

// Validate checks the field values on CreateScenarioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateScenarioResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateScenarioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateScenarioResponseMultiError, or nil if none found.
func (m *CreateScenarioResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateScenarioResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetScenario()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateScenarioResponseValidationError{
					field:  "Scenario",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateScenarioResponseValidationError{
					field:  "Scenario",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScenario()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateScenarioResponseValidationError{
				field:  "Scenario",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateScenarioResponseMultiError(errors)
	}

	return nil
}

// CreateScenarioResponseMultiError is an error wrapping multiple validation
// errors returned by CreateScenarioResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateScenarioResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateScenarioResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateScenarioResponseMultiError) AllErrors() []error { return m }

// CreateScenarioResponseValidationError is the validation error returned by
// CreateScenarioResponse.Validate if the designated constraints aren't met.
type CreateScenarioResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateScenarioResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateScenarioResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateScenarioResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateScenarioResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateScenarioResponseValidationError) ErrorName() string {
	return "CreateScenarioResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateScenarioResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateScenarioResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateScenarioResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateScenarioResponseValidationError{}

// Validate checks the field values on UpdateScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateScenarioRequestMultiError, or nil if none found.
func (m *UpdateScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateScenarioRequestValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateScenarioRequestValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateScenarioRequestValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetQuestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateScenarioRequestValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateScenarioRequestValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateScenarioRequestValidationError{
					field:  fmt.Sprintf("Questions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateScenarioRequestMultiError(errors)
	}

	return nil
}

// UpdateScenarioRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateScenarioRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateScenarioRequestMultiError) AllErrors() []error { return m }

// UpdateScenarioRequestValidationError is the validation error returned by
// UpdateScenarioRequest.Validate if the designated constraints aren't met.
type UpdateScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateScenarioRequestValidationError) ErrorName() string {
	return "UpdateScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateScenarioRequestValidationError{}

// Validate checks the field values on ScenarioQuestion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ScenarioQuestion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScenarioQuestion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScenarioQuestionMultiError, or nil if none found.
func (m *ScenarioQuestion) ValidateAll() error {
	return m.validate(true)
}

func (m *ScenarioQuestion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Criteria

	// no validation rules for Hint

	// no validation rules for Content

	if len(errors) > 0 {
		return ScenarioQuestionMultiError(errors)
	}

	return nil
}

// ScenarioQuestionMultiError is an error wrapping multiple validation errors
// returned by ScenarioQuestion.ValidateAll() if the designated constraints
// aren't met.
type ScenarioQuestionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScenarioQuestionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScenarioQuestionMultiError) AllErrors() []error { return m }

// ScenarioQuestionValidationError is the validation error returned by
// ScenarioQuestion.Validate if the designated constraints aren't met.
type ScenarioQuestionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScenarioQuestionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScenarioQuestionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScenarioQuestionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScenarioQuestionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScenarioQuestionValidationError) ErrorName() string { return "ScenarioQuestionValidationError" }

// Error satisfies the builtin error interface
func (e ScenarioQuestionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScenarioQuestion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScenarioQuestionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScenarioQuestionValidationError{}

// Validate checks the field values on DeleteScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteScenarioRequestMultiError, or nil if none found.
func (m *DeleteScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteScenarioRequestMultiError(errors)
	}

	return nil
}

// DeleteScenarioRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteScenarioRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteScenarioRequestMultiError) AllErrors() []error { return m }

// DeleteScenarioRequestValidationError is the validation error returned by
// DeleteScenarioRequest.Validate if the designated constraints aren't met.
type DeleteScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteScenarioRequestValidationError) ErrorName() string {
	return "DeleteScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteScenarioRequestValidationError{}

// Validate checks the field values on ListScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScenarioRequestMultiError, or nil if none found.
func (m *ListScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSortMethods() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListScenarioRequestValidationError{
						field:  fmt.Sprintf("SortMethods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListScenarioRequestValidationError{
						field:  fmt.Sprintf("SortMethods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListScenarioRequestValidationError{
					field:  fmt.Sprintf("SortMethods[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetPageIndex() < 0 {
		err := ListScenarioRequestValidationError{
			field:  "PageIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 1 {
		err := ListScenarioRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.SearchContent != nil {
		// no validation rules for SearchContent
	}

	if m.IsFavorite != nil {
		// no validation rules for IsFavorite
	}

	if m.IsFinished != nil {
		// no validation rules for IsFinished
	}

	if len(errors) > 0 {
		return ListScenarioRequestMultiError(errors)
	}

	return nil
}

// ListScenarioRequestMultiError is an error wrapping multiple validation
// errors returned by ListScenarioRequest.ValidateAll() if the designated
// constraints aren't met.
type ListScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScenarioRequestMultiError) AllErrors() []error { return m }

// ListScenarioRequestValidationError is the validation error returned by
// ListScenarioRequest.Validate if the designated constraints aren't met.
type ListScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScenarioRequestValidationError) ErrorName() string {
	return "ListScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScenarioRequestValidationError{}

// Validate checks the field values on ListScenarioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScenarioResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScenarioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScenarioResponseMultiError, or nil if none found.
func (m *ListScenarioResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScenarioResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetScenario() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListScenarioResponseValidationError{
						field:  fmt.Sprintf("Scenario[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListScenarioResponseValidationError{
						field:  fmt.Sprintf("Scenario[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListScenarioResponseValidationError{
					field:  fmt.Sprintf("Scenario[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for TotalPage

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListScenarioResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListScenarioResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListScenarioResponseValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListScenarioResponseMultiError(errors)
	}

	return nil
}

// ListScenarioResponseMultiError is an error wrapping multiple validation
// errors returned by ListScenarioResponse.ValidateAll() if the designated
// constraints aren't met.
type ListScenarioResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScenarioResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScenarioResponseMultiError) AllErrors() []error { return m }

// ListScenarioResponseValidationError is the validation error returned by
// ListScenarioResponse.Validate if the designated constraints aren't met.
type ListScenarioResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScenarioResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScenarioResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScenarioResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScenarioResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScenarioResponseValidationError) ErrorName() string {
	return "ListScenarioResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListScenarioResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScenarioResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScenarioResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScenarioResponseValidationError{}

// Validate checks the field values on GetScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetScenarioRequestMultiError, or nil if none found.
func (m *GetScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetScenarioRequestMultiError(errors)
	}

	return nil
}

// GetScenarioRequestMultiError is an error wrapping multiple validation errors
// returned by GetScenarioRequest.ValidateAll() if the designated constraints
// aren't met.
type GetScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetScenarioRequestMultiError) AllErrors() []error { return m }

// GetScenarioRequestValidationError is the validation error returned by
// GetScenarioRequest.Validate if the designated constraints aren't met.
type GetScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetScenarioRequestValidationError) ErrorName() string {
	return "GetScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetScenarioRequestValidationError{}

// Validate checks the field values on GetScenarioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetScenarioResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetScenarioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetScenarioResponseMultiError, or nil if none found.
func (m *GetScenarioResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetScenarioResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetScenario()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetScenarioResponseValidationError{
					field:  "Scenario",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetScenarioResponseValidationError{
					field:  "Scenario",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScenario()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetScenarioResponseValidationError{
				field:  "Scenario",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetScenarioResponseMultiError(errors)
	}

	return nil
}

// GetScenarioResponseMultiError is an error wrapping multiple validation
// errors returned by GetScenarioResponse.ValidateAll() if the designated
// constraints aren't met.
type GetScenarioResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetScenarioResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetScenarioResponseMultiError) AllErrors() []error { return m }

// GetScenarioResponseValidationError is the validation error returned by
// GetScenarioResponse.Validate if the designated constraints aren't met.
type GetScenarioResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetScenarioResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetScenarioResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetScenarioResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetScenarioResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetScenarioResponseValidationError) ErrorName() string {
	return "GetScenarioResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetScenarioResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetScenarioResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetScenarioResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetScenarioResponseValidationError{}

// Validate checks the field values on FavoriteScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FavoriteScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FavoriteScenarioRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FavoriteScenarioRequestMultiError, or nil if none found.
func (m *FavoriteScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FavoriteScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return FavoriteScenarioRequestMultiError(errors)
	}

	return nil
}

// FavoriteScenarioRequestMultiError is an error wrapping multiple validation
// errors returned by FavoriteScenarioRequest.ValidateAll() if the designated
// constraints aren't met.
type FavoriteScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FavoriteScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FavoriteScenarioRequestMultiError) AllErrors() []error { return m }

// FavoriteScenarioRequestValidationError is the validation error returned by
// FavoriteScenarioRequest.Validate if the designated constraints aren't met.
type FavoriteScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FavoriteScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FavoriteScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FavoriteScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FavoriteScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FavoriteScenarioRequestValidationError) ErrorName() string {
	return "FavoriteScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FavoriteScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFavoriteScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FavoriteScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FavoriteScenarioRequestValidationError{}

// Validate checks the field values on RatingScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RatingScenarioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RatingScenarioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RatingScenarioRequestMultiError, or nil if none found.
func (m *RatingScenarioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RatingScenarioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if val := m.GetRating(); val < 0 || val > 5 {
		err := RatingScenarioRequestValidationError{
			field:  "Rating",
			reason: "value must be inside range [0, 5]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RatingScenarioRequestMultiError(errors)
	}

	return nil
}

// RatingScenarioRequestMultiError is an error wrapping multiple validation
// errors returned by RatingScenarioRequest.ValidateAll() if the designated
// constraints aren't met.
type RatingScenarioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RatingScenarioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RatingScenarioRequestMultiError) AllErrors() []error { return m }

// RatingScenarioRequestValidationError is the validation error returned by
// RatingScenarioRequest.Validate if the designated constraints aren't met.
type RatingScenarioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RatingScenarioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RatingScenarioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RatingScenarioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RatingScenarioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RatingScenarioRequestValidationError) ErrorName() string {
	return "RatingScenarioRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RatingScenarioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRatingScenarioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RatingScenarioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RatingScenarioRequestValidationError{}

// Validate checks the field values on SubmitAnswerRequest_SubmittedAnswer with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SubmitAnswerRequest_SubmittedAnswer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitAnswerRequest_SubmittedAnswer
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SubmitAnswerRequest_SubmittedAnswerMultiError, or nil if none found.
func (m *SubmitAnswerRequest_SubmittedAnswer) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitAnswerRequest_SubmittedAnswer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuestionId

	// no validation rules for Answer

	if len(errors) > 0 {
		return SubmitAnswerRequest_SubmittedAnswerMultiError(errors)
	}

	return nil
}

// SubmitAnswerRequest_SubmittedAnswerMultiError is an error wrapping multiple
// validation errors returned by
// SubmitAnswerRequest_SubmittedAnswer.ValidateAll() if the designated
// constraints aren't met.
type SubmitAnswerRequest_SubmittedAnswerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitAnswerRequest_SubmittedAnswerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitAnswerRequest_SubmittedAnswerMultiError) AllErrors() []error { return m }

// SubmitAnswerRequest_SubmittedAnswerValidationError is the validation error
// returned by SubmitAnswerRequest_SubmittedAnswer.Validate if the designated
// constraints aren't met.
type SubmitAnswerRequest_SubmittedAnswerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitAnswerRequest_SubmittedAnswerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitAnswerRequest_SubmittedAnswerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitAnswerRequest_SubmittedAnswerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitAnswerRequest_SubmittedAnswerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitAnswerRequest_SubmittedAnswerValidationError) ErrorName() string {
	return "SubmitAnswerRequest_SubmittedAnswerValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitAnswerRequest_SubmittedAnswerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitAnswerRequest_SubmittedAnswer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitAnswerRequest_SubmittedAnswerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitAnswerRequest_SubmittedAnswerValidationError{}
